Part 1 â€” Introduction to Threading (0:00 â€“ 0:10)
ğŸ’¡ What is a Thread?

A thread is a lightweight sub-process â€” smallest unit of CPU execution.

In Java, every program has at least one main thread (the one that runs main()).

ğŸ“˜ Why use Threads?

To perform multiple tasks simultaneously.

Better CPU utilization.

Example: Media player â€” one thread plays music, another displays visuals.

ğŸ§  Analogy:

Imagine a restaurant:
One waiter = one thread.
More waiters (threads) can serve customers (tasks) simultaneously.
package training.Basics;

Part 2 â€” Thread Lifecycle (0:10 â€“ 0:35)
ğŸ§­ States of a Thread:
NEW â†’ RUNNABLE â†’ RUNNING â†’ WAITING â†’ TERMINATED

State	Description
NEW	----Thread created but not started
RUNNABLE----	After start() â€” ready to run
RUNNING	-----When scheduler picks it
WAITING / SLEEPING ---	Temporarily paused
TERMINATED ---	Finished execution

class Demo extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }

    public static void main(String[] args) {
        Demo d = new Demo(); // NEW
        d.start();           // RUNNABLE â†’ RUNNING
    }
}

start() â€” internally calls run() method â†’ creates a separate call stack.

internal segment
void start()
{ run();
}

Part 3 â€” Creating Threads 
âœ… Method 1: By extending Thread class
class A extends Thread {
    public void run() {
        System.out.println("Task executed by " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        A t1 = new A();
        A t2 = new A();
        t1.start();
        t2.start();
    }
}

 Explain: Each start() = new thread starts execution of run() in parallel.

Method 2: By implementing Runnable interface
class B implements Runnable {
    public void run() {
        System.out.println("Running via Runnable");
    }

    public static void main(String[] args) {
        B b = new B();
        Thread t = new Thread(b); // pass Runnable object
        t.start();
    }
}

Comparison Table:

extends Thread----	implements Runnable
Inherits Thread class	----Implements Runnable interface
Not good for multiple inheritance ----	Recommended way
Simpler for beginners ---	More flexible (used in real apps)


Part 4 â€” Thread Methods (1:10 â€“ 1:30)
Common Thread Methods
Method	Description
start()	--Starts the thread (calls run() internally)
run()--	Code executed by the thread
sleep(ms)	--Temporarily pauses thread
join()	--Waits for one thread to finish
isAlive()--	Checks if thread is still running
setName() / getName()---	Set or get thread name
setPriority()---	Assign priority (1â€“10)

Example:

class Test extends Thread {
    public void run() {
        for (int i = 1; i <= 3; i++) {
            System.out.println(Thread.currentThread().getName() + " : " + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {}
        }
    }

    public static void main(String[] args) throws Exception {
        Test t1 = new Test();
        Test t2 = new Test();
        t1.setName("Good");
        t2.setName("Deeds");
        t1.start();
        t2.start();

        t1.join(); // main waits until t1 finishes
        System.out.println("Main thread ends");
    }
}
Results
 output interleaving â€” demonstrates concurrency.

Thread Scheduler.

Part 5 â€” Multithreading (1:30 â€“ 1:55)
ğŸ’¡ What is Multithreading?

Executing multiple threads simultaneously â€” improves performance.

Example:

One thread for downloading file
Another for UI update
Another for playing sound

Example:

class Download extends Thread {
    public void run() {
        for (int i = 1; i <= 5; i++)
            System.out.println("Downloading file " + i);
    }
}
class Music extends Thread {
    public void run() {
        for (int i = 1; i <= 5; i++)
            System.out.println("Playing music " + i);
    }
}
public class App {
    public static void main(String[] args) {
        new Download().start();
        new Music().start();
    }
}

Result: Outputs interleave â†’ proves both running together.

Synchronization (1:55 â€“ 2:10)
âš ï¸ Problem:

When multiple threads access same resource â†’ inconsistent data.

ğŸ’¡ Solution:

Use synchronized keyword to lock shared resource.

Example

class Counter {
    int count = 0;
    synchronized void increment() {
        count++;
    }
}

public class SyncExample {
    public static void main(String[] args) throws Exception {
        Counter c = new Counter();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) c.increment();
        });
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) c.increment();
        });
        t1.start(); t2.start();
        t1.join(); t2.join();
        System.out.println("Count = " + c.count);
    }
}
Result:
Without synchronization: Result < 2000
With synchronization: Exact 2000
Thread-safe operation.

What is the Runnable Interface?

The Runnable interface is part of java.lang package.
It represents a task that can be executed by a thread.
It is used when you want to define the code that a thread should execute, but you donâ€™t want to extend the Thread class.

Declaration:

public interface Runnable {
    public abstract void run();
}

So, it has only one abstract method â€” run(), which makes it a Functional Interface (used in lambda expressions too).

Why do we need Runnable Interface?
If you extend the Thread class, your class cannot extend any other class (since Java doesnâ€™t support multiple inheritance).
ğŸ‘‰ To overcome this limitation, we implement the Runnable interface instead of extending Thread.

Syntax Example
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running using Runnable Interface...");
    }
}

public class TestRunnable {
    public static void main(String[] args) {
        MyRunnable r = new MyRunnable();         // Step 1: Create Runnable object
        Thread t = new Thread(r);                // Step 2: Pass Runnable to Thread
        t.start();                               // Step 3: Start the Thread
    }
}


Output:

Thread is running using Runnable Interface...
Step-by-step Explanation

Define a task by implementing Runnable and overriding the run() method.
Pass that task to a Thread object.
Call start() on the Thread object to start execution.

Internally, it calls the run() method of the Runnable target.

Real-life Analogy

Think of a Runnable as a job or task, and a Thread as a worker.
The job (Runnable) contains what to do.
The worker (Thread) executes the job.
You can assign different Runnables to different Threads, or even reuse the same Runnable for multiple threads.

Using Lambda Expression

Since Runnable has only one abstract method, we can use a lambda:

public class LambdaRunnable {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            System.out.println("Running thread using Lambda Runnable!");
        });
        t.start();
    }
}

Runnable vs Thread
Feature	Thread Class --	Runnable Interface
Inheritance	Must extend Thread---	Can implement Runnable
Flexibility	Canâ€™t extend another class	--- Can extend other classes
Structure	Has run() method directly	--- run() inside Runnable, passed to Thread
Preferred?	Not recommended for large apps	--- âœ… Preferred (cleaner, flexible)

What is the difference between calling run() and start()?
A:
start() â†’ Creates a new thread and then calls run() internally.
run() â†’ Just calls the method in the current thread (no new thread created).

how many run() can be present inside a class?
A class can have only one run() method that matches the signature defined by Runnable:
public void run()
But â€”
you can have other methods named run with different parameters or access modifiers â€” thatâ€™s called method overloading, not overriding.

Why only one real run()?

Because the Thread class and the Runnable interface both depend on a specific signature:
public void run()
When you call:
t.start();
â†’ Internally, the JVM looks for that exact method signature to execute inside the new thread.
If your class has multiple overloaded run() methods, only the no-argument, public void run() will be called automatically.
EG:
class MyThread implements Runnable {
    public void run() { // âœ… This one is called automatically
        System.out.println("Thread is running...");
    }
    
    public void run(int x) { // Overloaded method
        System.out.println("Run with parameter: " + x);
    }
    
    public void run(String msg) { // Another overload
        System.out.println(msg);
    }
}

public class TestRun {
    public static void main(String[] args) {
        Thread t = new Thread(new MyThread());
        t.start();               // Calls run() with no args automatically

        MyThread obj = new MyThread();
        obj.run(5);              // Manual call
        obj.run("Hello");        // Manual call
    }
}
OP:
Thread is running...
Run with parameter: 5
Hello

Concept	Meaning
âœ… public void run()	Automatically called when thread starts
âš™ï¸ run(int x) or others	Normal overloaded methods, not thread entry points
ğŸš« Multiple same-signature run()

So, you can have many run() methods (overloaded),
but only one valid Runnable run() will be treated as the threadâ€™s execution entry point.

Modern way of running a thread
new Thread(() -> {
    System.out.println("Task 1 running");
}).start();

new Thread(() -> {
    System.out.println("Task 2 running");
}).start();

The flow when you call start()

class MyThread extends Thread {
    public void run() {
        System.out.println(Thread.currentThread().getName() + " is running");
    }
}

public class Demo {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // âœ… starts new thread
        t1.run();    // âŒ runs in main thread only

        System.out.println("Main thread ends");
    }
}

OP:
Thread-0 is running
main is running
Main thread ends


Letâ€™s trace this visually ğŸ‘‡

âœ… Step-by-step JVM process
Step	What Happens
1ï¸âƒ£	You create a Thread object â†’ MyThread t = new MyThread();
2ï¸âƒ£	You call t.start();
3ï¸âƒ£	JVM checks threadâ€™s internal state â†’ if NEW, then ready to start
4ï¸âƒ£	JVM allocates a separate call stack (independent execution path) for this thread
5ï¸âƒ£	JVM internally calls the threadâ€™s native start0() (C/C++ native code)
6ï¸âƒ£	Once the new thread is started, JVM automatically calls t.run() inside that new thread
7ï¸âƒ£	Your run() method executes independently while the main thread continues in parallel

So start() is like telling JVM:

â€œHey, create a new CPU path for me and execute my run() inside it!â€



What if you call run() directly?

Then no new thread is created.

The run() code just executes as a normal method in the current (main) thread.
You can prove this using Thread.currentThread().getName() ğŸ‘‡

class Test extends Thread {
    public void run() {
        System.out.println("Running in: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        Test t = new Test();
        t.run();   // normal call
        t.start(); // real thread
    }
}


Output:

Running in: main
Running in: Thread-0

run() = normal method call
start() = new thread + internal call to run()

Internals of Thread class (simplified)

Hereâ€™s a simplified view of the actual Thread class source logic:

public class Thread implements Runnable {
    private Runnable target;   // holds the runnable task
    
    public Thread(Runnable target) {
        this.target = target;
    }

    public synchronized void start() {
        start0();  // native method that creates a new thread
    }

    private native void start0();

    public void run() {
        if (target != null)
            target.run();  // runs the Runnable's code
    }
}


So when you do:

Thread t = new Thread(new MyRunnable());
t.start();


the JVM will eventually call:

target.run();


on a new thread created by start0().

ğŸ§© 6ï¸âƒ£ Flow summary (to show students)
new Thread(...) â†’ start() 
             â†“
   JVM calls start0() (native)
             â†“
   JVM creates a new thread
             â†“
   JVM calls run() inside that thread

System.out.println(Thread.currentThread().getName());
Thisâ€™ll clearly see which thread executes which code.

The problem before locks

In multithreading, multiple threads often try to access the same resource (like a shared variable, object, or file).

For example ğŸ‘‡

class Counter {
    int count = 0;

    void increment() {
        count++;
    }
}


Now run this:

class Main {
    public static void main(String[] args) throws InterruptedException {
        Counter c = new Counter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) c.increment();
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) c.increment();
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final count = " + c.count);
    }
}

âš ï¸ Output problem

Expected count = 2000,
but you might get something like:

Final count = 1857


Thatâ€™s because both threads interfere with each other â€” a race condition.
Both read and write the same memory at the same time.

ğŸ§  2ï¸âƒ£ What is a Lock?

A Lock is a mechanism to restrict access so that only one thread can use a critical section (shared code) at a time.

It ensures thread safety by allowing mutual exclusion (mutex) â€” meaning one thread â€œlocksâ€ the code while itâ€™s working, and others must wait until the lock is released.

ğŸ§© 3ï¸âƒ£ Simplest Lock: synchronized keyword

Java gives an easy built-in lock via synchronized.

class Counter {
    int count = 0;

    synchronized void increment() {
        count++;
    }
}


Now, when one thread is executing increment(),
the other thread has to wait until itâ€™s done.

âœ… Output now:

Final count = 2000

ğŸ§© 4ï¸âƒ£ How synchronized works

When a thread enters a synchronized method or block, it acquires the lock on that object.

Other threads trying to access the same synchronized block/method on the same object must wait.

When the thread finishes, it releases the lock automatically.

Example with synchronized block
class Printer {
    void printDocs(String name) {
        synchronized(this) { // lock only this part
            for (int i = 1; i <= 3; i++) {
                System.out.println(name + " printing page " + i);
                try { Thread.sleep(500); } catch (InterruptedException e) {}
            }
        }
    }
}


So if multiple threads share one Printer object, theyâ€™ll print one at a time (no mixing).

ğŸ§© 5ï¸âƒ£ Advanced Lock â€” ReentrantLock (from java.util.concurrent.locks)

Java also provides a manual lock class with more control.

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Counter {
    int count = 0;
    Lock lock = new ReentrantLock();

    void increment() {
        lock.lock();  // acquire lock
        try {
            count++;
        } finally {
            lock.unlock();  // always release lock
        }
    }
}


âœ… ReentrantLock gives you more control:

You can tryLock() (attempt without waiting)

You can check if itâ€™s locked()

You must manually unlock it (so finally block is crucial)

ğŸ§© 6ï¸âƒ£ Difference between synchronized and ReentrantLock
Feature ----	synchronized ---	ReentrantLock
Lock release--- 	Automatic---	Manual (unlock())
Fairness (who gets lock next) ---	No ---	Can be made fair
Try to acquire lock without waiting	--- No	---Yes (tryLock())
Condition variables (wait/signal)	---via wait()/notify() ---	via newCondition()
Readability ---	Simple ---	More flexible
ğŸ§ 
ğŸ’¡ Teaching analogy
Think of a lock like a bathroom key ğŸšª â€” only one thread can enter.
When itâ€™s done, it gives back the key so the next person (thread) can go in.
synchronized = automatic door closer
ReentrantLock = manual key you must lock/unlock yourself



Example for Synchronize:
class Printer
{
	void printPage(String Doc) 
	{
		for(int i=0;i<=5;i++)
		{
			System.out.println(Doc+" - "+i);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
	}
}
class Mythread extends Thread
{
	Printer printer;
	String Doc;
	Mythread(Printer p,String D)
	{
		printer=p;
		Doc=D;
	}
	public void run()
	{
		printer.printPage(Doc);
	}
}

public class MainFunction {
    public static void main(String[] args) {
    	Printer p= new Printer();
    	Mythread t1=new Mythread(p,"ASK - ");
    	Mythread t2=new Mythread(p,"SEED - ");
    	
    	t1.start();
    	t2.start();
    	
          }
}


ğŸ†š 4ï¸âƒ£ Thread vs Runnable â€” Comparison Table
Feature	       extends Thread	  implements Runnable
Inheritance --	  Not possible to extend any other class --	Can still extend other classes
Flexibility	-- Less flexible --	More flexible
Reusability	-- Each class must be a Thread	 --- Can share same Runnable with multiple threads
Best Practice---	âŒ Not recommended (old style) --	âœ… Recommended (modern style)
Object Type --	Thread is the thread	--- Runnable is executed by a thread


Example:
class A extends Thread {
    public void run() {
        System.out.println("Thread A running...");
    }
}

class B implements Runnable {
    public void run() {
        System.out.println("Thread B running...");
    }
}

public class TestThreads {
    public static void main(String[] args) {
        A t1 = new A();
        Thread t2 = new Thread(new B());

        t1.start();
        t2.start();
    }
}
Situation	Choose
You just need one simple thread	extends Thread
You want to share data between threads or reuse logic	implements Runnable
You are using thread pooling or executors (in real projects)

what happens if t1.start(). if no run() in thread class?
Scenario:
class MyThread extends Thread {
    // No run() method here
}

public class Test {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();
    }
}
Answer:
Compilation: âœ…
No error â€” this is perfectly valid Java code.

âœ… Runtime: âœ…
The thread starts successfully â€” but nothing happens visibly.

When you call:
t1.start();

The Thread class internally calls:
t1.run();
But since you did not override run(),
the default implementation of run() from Thread class executes.
Default Implementation (inside Thread class):
public void run() {
    if (target != null) {
        target.run();
    }
}


ğŸ‘‰ Here, target refers to the Runnable object that might have been passed to the threadâ€™s constructor.

If you didnâ€™t pass any Runnable, target is null.



Thread Life Cycle in Java

Every thread in Java goes through 5 main states (as per the Thread.State enum in Java):

Stage	Description
1ï¸âƒ£ New (Born)	Thread object is created but not yet started.
2ï¸âƒ£ Runnable (Ready to Run)	After start() is called, thread is ready and waiting for CPU scheduling.
3ï¸âƒ£ Running	Thread scheduler picks it â€” now itâ€™s executing run().
4ï¸âƒ£ Blocked / Waiting / Sleeping	Thread temporarily paused (due to I/O, sleep(), wait(), etc.).
5ï¸âƒ£ Terminated (Dead)	run() method completes or thread is stopped.
ğŸ§© ğŸ§± Diagram (Conceptually)
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚     New      â”‚
          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚  start()
                 â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   Runnable   â”‚
          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚  gets CPU
                 â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   Running    â”‚
          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
     sleep(), wait(), I/O â”‚
                 â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Blocked/Wait â”‚
          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ resume(), notify(), I/O done
                 â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Terminated   â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ§  Example Code to Show States
class DemoThread extends Thread {
    public void run() {
        System.out.println("Thread is Running...");
        try {
            Thread.sleep(1000); // moves to TIMED_WAITING state
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Thread is finishing...");
    }
}

public class MainFunction {
    public static void main(String[] args) throws InterruptedException {
        DemoThread t1 = new DemoThread();

        System.out.println("1ï¸âƒ£ State after creation: " + t1.getState()); // NEW
        t1.start();

        System.out.println("2ï¸âƒ£ State after start(): " + t1.getState()); // RUNNABLE

        Thread.sleep(100); // give time for t1 to start
        System.out.println("3ï¸âƒ£ State after short delay: " + t1.getState()); // RUNNABLE or TIMED_WAITING

        t1.join();
        System.out.println("4ï¸âƒ£ Final State: " + t1.getState()); // TERMINATED
    }
}

ğŸ§© Output (Typical)
1ï¸âƒ£ State after creation: NEW
2ï¸âƒ£ State after start(): RUNNABLE
Thread is Running...
3ï¸âƒ£ State after short delay: TIMED_WAITING
Thread is finishing...
4ï¸âƒ£ Final State: TERMINATED

ğŸ§  Short Notes for Class:
State	Trigger	Meaning
NEW	Object created (new Thread())	Thread not yet started
RUNNABLE	start()	Ready for CPU
RUNNING	Scheduler picks it	Executes run()
BLOCKED/WAITING	sleep(), wait(), join()	Temporarily paused
TERMINATED	run() completes	Thread ends

Commonly Used Methods in Thread Class
Method	Description
start()	Starts a new thread â€” internally calls run()
run()	Code to execute inside the thread
sleep(ms)	Pauses current thread for given milliseconds
join()	Waits for one thread to finish before continuing
getName() / setName()	Gets or sets the thread name
getId()	Returns unique ID assigned to the thread
getState()	Returns threadâ€™s current state
isAlive()	Checks if thread is still running
setPriority(int)	Sets threadâ€™s priority (1â€“10)
getPriority()	Gets threadâ€™s current priority
yield()	Temporarily pauses current thread to give others a chance
interrupt()	Sends an interrupt signal to a sleeping or waiting thread
currentThread()	Returns a reference to the currently running thread
ğŸ§  2ï¸âƒ£ Thread Scheduler
ğŸ“– Definition:

The Thread Scheduler is a part of the JVM that decides which thread runs next when multiple threads are ready (Runnable).

âš™ï¸ Scheduler Characteristics:

The scheduling is handled by JVM & OS â€” not by the programmer.

You can only suggest (via priority), not control.

Every time slice, scheduler picks one Runnable thread to execute.

âš™ï¸ Thread Priorities

Java priorities range from 1 to 10:

Thread.MIN_PRIORITY = 1
Thread.NORM_PRIORITY = 5  // default
Thread.MAX_PRIORITY = 10


ğŸ”¹ Example:

t1.setPriority(Thread.MAX_PRIORITY);
t2.setPriority(Thread.MIN_PRIORITY);


âš ï¸ Priority doesnâ€™t guarantee execution order â€” it just gives a hint to the scheduler.

ğŸ§© 3ï¸âƒ£ Wait(), Notify(), and NotifyAll()

These are Object class methods, not Thread methods.

Method	Meaning
wait()	Makes a thread go into waiting state until another thread calls notify()
notify()	Wakes up one thread waiting on the same object
notifyAll()	Wakes up all waiting threads on the same object

ğŸ§  Used for communication between threads (called Inter-Thread Communication).

âš™ï¸ 4ï¸âƒ£ Simple Example â€” wait() and notify()

Letâ€™s make it super simple ğŸ‘‡

class SharedResource {
    synchronized void produce() {
        System.out.println("Producer: Producing...");
        try {
            wait();  // release lock and wait
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Producer: Resumed after notification!");
    }

    synchronized void consume() {
        System.out.println("Consumer: Waiting 2 seconds before notifying...");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        notify(); // wake up waiting thread
        System.out.println("Consumer: Notified producer!");
    }
}

public class MainFunction {
    public static void main(String[] args) {
        SharedResource obj = new SharedResource();

        Thread producer = new Thread(() -> obj.produce());
        Thread consumer = new Thread(() -> obj.consume());

        producer.start();
        consumer.start();
    }
}

ğŸ§  Explanation

Both threads share the same object obj.

producer enters produce(), locks the object, then calls wait() â†’ releases the lock and waits.

consumer gets the lock, runs consume(), and after 2 seconds calls notify().

notify() wakes the waiting producer thread.

producer resumes from where it left (after wait()).

ğŸ” Output (Expected)
Producer: Producing...
Consumer: Waiting 2 seconds before notifying...
Consumer: Notified producer!
Producer: Resumed after notification!

ğŸ§© 5ï¸âƒ£ Important Rules

wait(), notify(), and notifyAll() can be called only inside a synchronized block or method.
Otherwise â†’ IllegalMonitorStateException.

The thread must own the objectâ€™s lock before calling them.

wait() releases the lock.

notify() wakes up one waiting thread.

notifyAll() wakes up all waiting threads.